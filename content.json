{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://gearoruni.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"09-10","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"09-10","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"09-10","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-10","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"09-10","excerpt":""}],"posts":[{"title":"背包系统学习记录","text":"[前言]咿呀，磕磕碰碰终于把背包系统学习完了，我还是第一次制作这么大的系统，于是在迈入对话与任务系统前想用博客总结一下，我不怎么会文档排版，大概会有些乱（反正没人看），下面我会从大框架开始由表向里的回忆整个系统制作。 [介绍]1.UI背包系统我们需要制作背包、快捷栏、人物面板（装备栏），虽然看起来不一样，但其实在背后它们都是一样的逻辑，在UI界面，由一个巨大的容器（container）包裹住许多小的格子（holder），每一个格子下有两个子物体(item)，一个用于存放当前格子里存放的物品的信息，另一个负责显示物品的图标与数量，我将负责显示的对象设为存放信息对象的子物体，毕竟显示用的图标与数量也是物品信息；在背后每一个container会有一个资产文件，它充当了我们每一个container的数据库，我们的物品会真正地存放在这些数据库中。下面的图显示了他们之间的关系。 2.代码 item item作为背包系统最小的单位，挂载的代码只需要记录以下信息 显示图标的gameObject 显示数量的gameObject item所在的container对应的数据库 item在container中的索引（也就是这个item是第几个格子，用于在数据库中读取信息） 函数 item只需要一个函数SetUp(itemData_SO item,int itemAmount)（itemData_SO就是记录物品信息的自定义类型），它接受来自holder给的物品信息以及数量，用于对UI进行刷新 注解 唯一的函数并没有用到数据库以及索引，因为这两个变量是由holder调用，详情见holder holder holder在整个背包系统中负责记录以下信息 所在container的类型 对应的item的gameObject 函数 UpdateItem() 这个函数根据container的类型确定item的数据库，同时根据item的索引读取数据库，将信息传给item。这个函数也会可以执行一些别的功能，比如当container类型处于武器栏时，可以调用切换武器的相关函数。 UseItem() 这个函数负责消耗品的使用，将数据库对应数量减少，同时调用对应物品的功能函数，最后让item更新UI。 还有很多关于拖拽物品的函数，详情见拖拽。 注解 container类型是指这个背包承担的功能，比如一般的背包栏、快捷栏、武器装备栏，作出区分是因为一般情况下我们不能装备消耗品，也不会将装备放在快捷栏 holder的作用是最大的，item和container都只负责更新，只有holder承担全部的背包功能，当然本文只是提供背包系统的思路，你也可以将这些功能分配给别的部分，比如本文的数据库由item记录，由holder向其读取数据，你可以让container记录，只要代码能跑就行（乐） container container负责记录它手下的holder，一个数组即可搞定 函数 freshUI() 按照holder在数组中的索引给item的数据库索引赋值，这样就可以做到每个item都顺序对应一个数据库区域，同时调用UpdataItem()更新UI 注解 container就是个容器 补充 数据库我们会提前建立好，并将引用提供给inventoryManager这是一种单例模式","path":"2022/10/02/背包系统学习记录/","date":"10-02","excerpt":"","tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://gearoruni.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}]},{"title":"UI参数PointerEventData","text":"【事件接口】概述​ 关于UI事件，指的是对于UI界面本身的交互，例如拖动背包栏、拖拽背包中的物体、鼠标放在物品上时显示物品描述等等，如果想要自己实现，我们可能会选择射线检测的方式配合代码来锁定UI，幸运的是Unity官方提供了许多封装接口，让我们可以跳过这一阶段而把重心放在功能开发上。 这里放上部分接口 接口名 函数 功能 IPointerClickHandler OnPointerClick 当检测到鼠标单次点击时调用函数 IPointerDownHandler OnPointerDown 当检测到鼠标按下时持续调用函数，松开停止 IPointerUpHandler OnPointerUp 鼠标释放时调用，需要先调用IPointerDownHandler IPointerEnterHandler OnPointerEnter 当鼠标进入该UI对象时调用函数 IPointerExitHandler OnPointerExit 当鼠标离开该UI对象时调用函数 IBeginDragHandler OnBeginDrag 在开始拖动时调用函数，需要连同IDragHandler一起实现 IDragHandler OnDrag 在拖动过程中持续调用函数 IEndDragHandler OnEndDrag 停止拖动即松开鼠标时调用函数 在实现这些接口时，我们会发现函数会自带一个PointerEventData类型的参数，这个参数会记录当前帧鼠标与UI交互的各种信息，下面会介绍部分变量（持续更新） 【clickCount】这个变量会返回连续单击鼠标的次数，连续点击时这个数值会一直上涨，当点击间隔时间小于某个值时（官网没有给具体时间，我也没具体测试，但经常玩游戏的大家应该都能理解连击和单击的区分吧），变量会重新计数。 【delta】这个变量会返回当前帧的鼠标坐标相对于上一帧的增量（vector2），也就是鼠标与上一帧相比移动的距离与方向，因为这个增量是以上一帧鼠标的坐标为原点，所以要注意将鼠标本身的坐标区分开（鼠标的坐标是以左下角为原点）","path":"2022/09/29/UI事件接口以及参数PointerEventData/","date":"09-29","excerpt":"","tags":[{"name":"UI","slug":"UI","permalink":"https://gearoruni.github.io/tags/UI/"},{"name":"接口","slug":"接口","permalink":"https://gearoruni.github.io/tags/%E6%8E%A5%E5%8F%A3/"}]},{"title":"单例模式","text":"单例模式 描述：在类中设置一个此类的静态属性，利用静态变量的特性，可以在其它类中无需创建而直接调用同一个类，各项数据都会在此类登记，也会在此类被调用，方便管理，一般用于各种Manager。","path":"2022/09/15/单例模式/","date":"09-15","excerpt":"","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gearoruni.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"委托事件","text":"描述：c#提供Action的无返回值的泛型委托，由某一个类发布一个委托，其他类的函数订阅这个委托，当这个委托被启动后，所有订阅委托的函数会按照订阅顺序依次执行 声明：public event Action&lt;T&gt; OnMouseClick; 订阅：MouseManager.Instance.OnMouseClick+=MoveToTarget; 取消订阅：MouseManager.Instance.OnMouseClick-=MoveToTarget; 启动：OnMouseClick?.Invoke(T t); 实例： 1234//定义public event Action&lt;Vector3&gt; OnMouseClick;//启动OnMouseClick?.Invoke(hitinfo.point); 123456//订阅if(MouseManager.Instance!=null)&#123; MouseManager.Instance.OnMouseClick += MoveToTarget; MouseManager.Instance.OnEnemyClick += AttackTarget;&#125;","path":"2022/09/15/委托事件/","date":"09-15","excerpt":"","tags":[{"name":"C#","slug":"C","permalink":"https://gearoruni.github.io/tags/C/"},{"name":"语法","slug":"语法","permalink":"https://gearoruni.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"Transform","text":"Transform 插件名：Transform 描述：文档上写的是“记录对象的位置、旋转和缩放”，其实还有其他功能，比如改变父级，统计子级数量等 函数与属性: childCount: 参数：无 功能：返回对象的子对象数量 forward: 参数：无 功能：以标准矢量的形式返回对象在世界坐标中的蓝轴（Z轴），一般就是人物前方 right: 参数：无 功能：返回红轴（X轴） up: 参数：无 功能：返回绿轴（Y轴） localScale: 参数：float 功能：相对于父级的变换缩放（在2D项目中从1到-1可以实现人物反转） rotation: 参数：Quaternion 功能：改变转向（只建议将别的对象的Quaternion进行赋值，直接修改可能发生意料之外的效果） position: 参数：vector3 功能：改变对象坐标 GetChild(): 参数：int 功能：按照序号返回对应的子对象的Transform，这个序号按照对象从上而下的列表顺序排序，第一个是0 LookAt(): 参数：Transform，vector3 功能：使对象的蓝轴（z轴）指向目标，同时绿轴（y轴）指向vector3的方向，若未指定vector3则默认使用世界坐标的Y轴（也就是垂直向上） SetParent(): 参数：Transform，bool 功能：将对象变为目标的子对象，bool默认为true，可以保持与之前相同的世界坐标位置旋转和缩放 SetPositionAndRotation(): 参数：vector3，Quaternion 功能：设置变换组件的世界坐标位置和旋转","path":"2022/09/15/Transform/","date":"09-15","excerpt":"","tags":[{"name":"插件","slug":"插件","permalink":"https://gearoruni.github.io/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"协程","text":"协程 描述：c#提供一种特殊的返回值IEnumerator,使用yield return返回，在Unity中，该返回值记录当前协程暂停地址，下一帧从该地址进行。 建立协程： 声明：IEnumerator MoveToTarget(); 定义：与一般函数相同，在需要分帧完成的代码之后使用yield return返回。 调用（Unity）： StartCoroutine(函数名)：启动协程 StopCoroutine(函数名)：停止协程 StopAllCoroutine()：停止所有协程 功能：Unity中函数功能均是在同一帧中完成，如果需要某种功能在若干帧中完成，如设计攻击敌人的函数，执行时需要先接近敌人再展开攻击，接近的过程需要在若干帧中完成，在一般函数中，这个过程会在一帧中完成，表现结果就是瞬移（如果使用NavMeshAgent来实现移动，会因为该插件在移动之前需要花几帧的时间使路径可用，从而陷入移动无法开始，但本帧又因为距离没满足要求而不停执行移动的死循环），因此需要使用协程将函数放在多帧中完成。 示例： 123456789101112131415161718IEnumerator MoveToTarget() &#123; //agent为NavMeshAgent的实例 agent.isStopped = false; transform.LookAt(attackTarget.transform); while(Vector3.Distance(attackTarget.transform.position,transform.position)&gt;2f) &#123; agent.destination = attackTarget.transform.position;//设置目标坐标，agent会尝试向其移动 yield return null;//本帧结束，下一帧从此行继续，直到距离小于2f结束循环 &#125; agent.isStopped = true; if(lastAttackTime&lt;0) &#123; lastAttackTime = 0.5f; anim.SetTrigger(&quot;Attack&quot;); playerData.isCritical =UnityEngine.Random.value &lt;= playerData.attackData.CriticalChance; &#125; &#125;","path":"2022/09/15/协程/","date":"09-15","excerpt":"","tags":[{"name":"C#","slug":"C","permalink":"https://gearoruni.github.io/tags/C/"},{"name":"语法","slug":"语法","permalink":"https://gearoruni.github.io/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"Animator","text":"Animator 插件名：Animator 描述：用于控制动画的系统，即动画控制器 函数与属性： Set系列：设置某个指定变量的值，如SetBool() 参数1：string name,bool value 参数2：int id,bool value name是设置的参数名字，value的数据类型根据函数变换，id即是在动画页面参数列表的顺序，从0开始；也存在不需要value的函数，如SetTrigger,在设置后参数变为勾选状态，在动画完成后自动取消勾选。 Get系列：返回给定参数的当前值，如GetBool() 参数1：string name 参数2：int id 同Set一样，因为是返回当前值而无需value。","path":"2022/09/13/Animator/","date":"09-13","excerpt":"","tags":[{"name":"插件","slug":"插件","permalink":"https://gearoruni.github.io/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"pictest","text":"diyi1234main()&#123; return 0;&#125;","path":"2022/09/11/pictest/","date":"09-11","excerpt":"","tags":[]},{"title":"“NavMeshAgent”","text":"插件名：NavMeshAgent 描述：此组件附加到游戏中的某个移动角色，以允许该角色使用导航网格在场景中导航。 引用： 命名空间：using UnityEngine.AI 函数与属性： isStopped: 参数：布尔值 功能：如果设为 True，则导航网格代理将停止沿着当前路径移动。如果在导航网格代理停止后设为 False，它将恢复沿着当前路径移动。 destination: 参数：vector3 功能：可使挂载该插件的对象移动至制定目标或周围的目标。 velocity: 参数：vector3 功能：可以返回对象当前的速度，也可以给与赋值来手动控制对象速度","path":"2022/09/10/NavMeshAgent/","date":"09-10","excerpt":"","tags":[{"name":"插件","slug":"插件","permalink":"https://gearoruni.github.io/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"test","text":"第一行 嵌套 第三行","path":"2022/09/10/test/","date":"09-10","excerpt":"","tags":[{"name":"逆向","slug":"逆向","permalink":"https://gearoruni.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2022/09/10/hello-world/","date":"09-10","excerpt":"","tags":[]}],"categories":[],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"https://gearoruni.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"UI","slug":"UI","permalink":"https://gearoruni.github.io/tags/UI/"},{"name":"接口","slug":"接口","permalink":"https://gearoruni.github.io/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"设计模式","slug":"设计模式","permalink":"https://gearoruni.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"C#","slug":"C","permalink":"https://gearoruni.github.io/tags/C/"},{"name":"语法","slug":"语法","permalink":"https://gearoruni.github.io/tags/%E8%AF%AD%E6%B3%95/"},{"name":"插件","slug":"插件","permalink":"https://gearoruni.github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"逆向","slug":"逆向","permalink":"https://gearoruni.github.io/tags/%E9%80%86%E5%90%91/"}]}